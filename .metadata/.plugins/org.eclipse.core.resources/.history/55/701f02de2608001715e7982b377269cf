// represent the interface IPredicator
interface IPred<T> {
    boolean apply(T t);
}

class SameString implements IPred<String> {
    String s1;

    SameString(String s1) {
        this.s1 = s1;
    }

    public boolean apply(String s) {
        return s1.equals(s);
    }
}



class Deque<T> {
    Sentinel<T> header;

    Deque() {
        this.header = new Sentinel<T>();
    }

    Deque(Sentinel<T> s) { 
        this.header = s;
    }

    int size() {
        return this.header.next.sizeHelp();
    }


    void addAtHead(T given) {
        Node<T> t = new Node<T>(given);
        t.add(this.header, this.header.next);
    }


    void addAtTail(T given) {
        Node<T> t = new Node<T>(given);
        t.add(this.header.prev, this.header);
    }

    T removeFromHead() {
        return this.header.next.remove();
    }

    T removeFromTail() {
        return this.header.prev.remove();
    }


    ANode<T> find(IPred<T> pred) {
        return this.header.next.findHelp(pred);
    }

    void removeNode(ANode<T> toRemove) {
        if (toRemove != (ANode<T>) this.header) {
            toRemove.remove();
        }
    }
}

// represents a union of data:
//  - Sentinel<T>
//  - Node<T>
abstract class ANode<T> {
    ANode<T> prev;
    ANode<T> next;

    int sizeHelp() {
        return 1 + this.next.sizeHelp();
    }

    abstract ANode<T> findHelp(IPred<T> pred);


    abstract T remove();
}

// WHY I CANT USE SUPER FOR ABSTRACT CLASS HERE
class Sentinel<T> extends ANode<T> {
    Sentinel() {
        this.prev = this;
        this.next = this;
    }

    // helps size() determine the length of the deque
    public int sizeHelp() {
        return 0;
    }

    public ANode<T> findHelp(IPred<T> pred) {
        return this;
    }

    public T remove() {
        throw new RuntimeException("attempting to remove from empty deque");
    }
}


class Node<T> extends ANode<T> {
    T data;

    Node(T data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }


    Node(T data, ANode<T> next, ANode<T> prev) {
        this.data = data;
        if ((prev == null) || (next == null)) {
            throw new IllegalArgumentException("given node is null");
        }
        this.prev = prev;
        this.next = next;
        this.prev.next = this;
        this.next.prev = this;
    }

    public ANode<T> findHelp(IPred<T> pred) {
        if (pred.apply(this.data)) {
            return this;
        }
        else {
            return this.next.findHelp(pred);
        }
    }

    void add(ANode<T> prev, ANode<T> next) {
        prev.next = this;
        next.prev = this;
        this.prev = prev;
        this.next = next;
    }

    T remove() {
        ANode<T> prev = this.prev;
        ANode<T> next = this.next;
        prev.next = next;
        next.prev = prev;
        return this.data;
    }
}
