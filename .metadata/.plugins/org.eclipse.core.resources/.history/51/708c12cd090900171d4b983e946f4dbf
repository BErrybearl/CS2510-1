import tester.*;

// represent the interface IPredicator
interface IPred<T> {
  boolean apply(T t);
}

class SameString implements IPred<String> {
  String s1;

  SameString(String s1) {
    this.s1 = s1;
  }

  public boolean apply(String s) {
    return s1.equals(s);
  }
}

class Deque<T> {
  Sentinel<T> header;

  Deque() {
    this.header = new Sentinel<T>();
  }

  Deque(Sentinel<T> s) {
    this.header = s;
  }

  int size() {
    return this.header.next.sizeHelp();
  }

  void addAtHead(T given) {
    Node<T> t = new Node<T>(given);
    t.add(this.header, this.header.next);
  }

  void addAtTail(T given) {
    Node<T> t = new Node<T>(given);
    t.add(this.header.prev, this.header);
  }

  T removeFromHead() {
    return this.header.next.remove();
  }

  T removeFromTail() {
    return this.header.prev.remove();
  }

  ANode<T> find(IPred<T> pred) {
    return this.header.next.findHelp(pred);
  }

  void removeNode(ANode<T> toRemove) {
    if (toRemove != (ANode<T>) this.header) {
      toRemove.remove();
    }
  }
}

// represents a union of data:
// - Sentinel<T>
// - Node<T>
abstract class ANode<T> {
  ANode<T> prev;
  ANode<T> next;

  int sizeHelp() {
    return 1 + this.next.sizeHelp();
  }

  abstract ANode<T> findHelp(IPred<T> pred);

  abstract T remove();
}

// WHY I CANT USE SUPER FOR ABSTRACT CLASS HERE
class Sentinel<T> extends ANode<T> {
  Sentinel() {
    this.prev = this;
    this.next = this;
  }

  // helps size() determine the length of the deque
  public int sizeHelp() {
    return 0;
  }

  public ANode<T> findHelp(IPred<T> pred) {
    return this;
  }

  public T remove() {
    throw new RuntimeException("attempting to remove from empty deque");
  }
}

class Node<T> extends ANode<T> {
  T data;

  Node(T data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }

  Node(T data, ANode<T> next, ANode<T> prev) {
    this.data = data;
    if ((prev == null) || (next == null)) {
      throw new IllegalArgumentException("given node is null");
    }
    this.prev = prev;
    this.next = next;
    this.prev.next = this;
    this.next.prev = this;
  }

  public ANode<T> findHelp(IPred<T> pred) {
    if (pred.apply(this.data)) {
      return this;
    }
    else {
      return this.next.findHelp(pred);
    }
  }

  void add(ANode<T> prev, ANode<T> next) {
    prev.next = this;
    next.prev = this;
    this.prev = prev;
    this.next = next;
  }

  T remove() {
    ANode<T> prev = this.prev;
    ANode<T> next = this.next;
    prev.next = next;
    next.prev = prev;
    return this.data;
  }
}


class ExamplesDeque {

  Sentinel<String> sent1;
  Sentinel<String> sent2;
  Sentinel<Integer> sent3;
  Sentinel<String> senttest;

  ANode<String> node1;
  ANode<String> node2;
  ANode<String> node3;
  ANode<String> node4;

  ANode<Integer> nodea;
  ANode<Integer> nodeb;
  ANode<Integer> nodec;
  ANode<Integer> noded;
  ANode<Integer> nodee;

  Deque<String> deque1;
  Deque<String> deque2;
  Deque<Integer> deque3;
  Deque<String> dequetest;

  // initialize the Deque list
  void initDeque() {
      sent1 = new Sentinel<String>();
      sent2 = new Sentinel<String>();
      node1 = new Node<String>("abc", sent2, sent2);
      node2 = new Node<String>("bcd", sent2, node1);
      node3 = new Node<String>("cde", sent2, node2);
      node4 = new Node<String>("def", sent2, node3);

      sent3 = new Sentinel<Integer>();
      nodea = new Node<Integer>(1, sent3, sent3);
      nodeb = new Node<Integer>(2, sent3, nodea);
      nodec = new Node<Integer>(3, sent3, nodeb);
      noded = new Node<Integer>(4, sent3, nodec);
      nodee = new Node<Integer>(5, sent3, noded);

      deque1 = new Deque<String>();
      deque2 = new Deque<String>(this.sent2);
      deque3 = new Deque<Integer>(this.sent3);

      senttest = new Sentinel<String>();
      dequetest = new Deque<String>(this.senttest);
  }
  
  // test the method size
  void testSize(Tester t) {
      // initialize
      this.initDeque();
      t.checkExpect(this.deque2.size(), 4);
      t.checkExpect(this.deque1.size(), 0);
      t.checkExpect(this.deque3.size(), 5);
  }


  // test the method addAtHead
  void testAddAtHead(Tester t) {

      initDeque();
      t.checkExpect(this.sent2.next, this.node1);
      t.checkExpect(this.sent1.next, this.sent1);

      initDeque();
      this.deque1.addAtHead("def");
      this.deque1.addAtHead("cde");
      this.deque1.addAtHead("bcd");
      this.deque1.addAtHead("abc");

      t.checkExpect(deque1, deque2);
  }

  // test the method addAdTail
  void testAddAtTail(Tester t) {

      initDeque();

      this.dequetest.addAtTail("abc");
      this.dequetest.addAtTail("bcd");
      this.dequetest.addAtTail("cde");
      this.dequetest.addAtTail("def");
      t.checkExpect(this.dequetest, this.deque2);

  }

  // test the method removeFromHead
  void testRemoveFromHead(Tester t) {
      // initialize
      initDeque();
      t.checkExpect(this.sent2, this.sent1);
      t.checkException(new RuntimeException(
              "Can't try to remove on a Sentinel!"), sent1, "removeFromHead");
      initDeque();
      this.deque2.removeFromHead();
      t.checkExpect(this.deque2.header.next, this.node2);
      t.checkExpect(this.deque2.header.prev, this.node4);
  }

  // test the method removeFromTail
  void testRemoveFromTail(Tester t) {
      // initialize
      initDeque();
      t.checkExpect(this.sent2.next, this.node1);
      t.checkExpect(this.sent2.prev, this.node3);
      t.checkException(new RuntimeException(
              "Can't try to remove on a Sentinel!"), sent1, "removeFromTail");
      // initialize
      initDeque();
      this.deque2.removeFromTail();
      t.checkExpect(this.deque2.header.next, this.node1);

  }
}
