import tester.Tester;

interface IComparator<T> {

  int compare(T t1, T t2);

}

class BooksByTitle implements IComparator<Book> {

  public int compare(Book b1, Book b2) {
    return b1.title.compareTo(b2.title);

  }

}

class BooksByAuthor implements IComparator<Book> {

  public int compare(Book b1, Book b2) {
    return b1.author.compareTo(b2.author);
  }

}

class BooksByPrice implements IComparator<Book> {

  public int compare(Book b1, Book b2) {
    return b1.price - b2.price;

  }

}

abstract class ABST<T> {

  IComparator<T> order;

  ABST(IComparator<T> order) {
    this.order = order;
  }

  abstract boolean isLeaf();

  abstract ABST<T> insert(T t);

  abstract T getLeast();

  abstract ABST<T> getAllButLeast();

  abstract boolean sameTree(ABST<T> given);

}

class Leaf<T> extends ABST<T> {

  Leaf(IComparator<T> order) {
    super(order);
  }

  boolean isLeaf() {
    return true;
  }

  ABST<T> insert(T t) {
    return new Node<T>(this.order, t, new Leaf<T>(this.order), new Leaf<T>(this.order));
  }

  T getLeast() {
    throw new RuntimeException("No least item of an empty tree");
  }

  
  ABST<T> getAllButLeast() {
    throw new RuntimeException("No items in an empty tree");
  }

  boolean sameTree(ABST<T> given) {
    return given.isLeaf();
  }

}

class Node<T> extends ABST<T> {

  T data;
  ABST<T> left;
  ABST<T> right;

  Node(IComparator<T> order, T data, ABST<T> left, ABST<T> right) {
    super(order);
    this.data = data;
    this.left = left;
    this.right = right;
  }

  boolean isLeaf() {
    return false;
  }

  ABST<T> insert(T t) {
    return null;
  }

  T getLeast() {
    if (this.left.isLeaf()) {
      return this.data;
    }
    else {
      return this.left.getLeast();
    }
  }

  ABST<T> getAllButLeast() {

    if (this.left.equals(this.getLeast())) {
      return this.right;
    }

    else {
      return new Node<T>(this.order, this.data, this.left.getAllButLeast(), this.right);
    }
    
  }

  @Override
  boolean sameTree(ABST<T> given) {
    return false;
  }
}

interface IList<T> {

}

class MtList<T> implements IList<T> {

}

class ConsList<T> implements IList<T> {
  T first;
  IList<T> rest;

  ConsList(T first, IList<T> rest) {
    this.first = first;
    this.rest = rest;
  }
}

class Book {

  String title;
  String author;
  int price;

  Book(String title, String author, int price) {
    this.title = title;
    this.author = author;
    this.price = price;
  }

  public boolean sameBook(Book given) {
    return this.title.equals(given.title) && this.author.equals(given.author)
        && this.price == given.price;
  }
}

class ExamplesABST {

  Book b1 = new Book("Animal Farm", "George Orwell", 10);
  Book b2 = new Book("How to Design Programs", "Matthias Felleisen", 1);
  Book b3 = new Book("Lord of the Rings", "J.R.R. Tolkien", 5);
  Book b4 = new Book("ZZZZZZ", "Connor", 3);
  Book b5 = new Book("AA", "Connor", 3);

  IComparator<Book> titleComp = new BooksByTitle();
  IComparator<Book> authorComp = new BooksByAuthor();
  IComparator<Book> priceComp = new BooksByPrice();

  ABST<Book> lfTitle = new Leaf<Book>(titleComp);
  ABST<Book> lfAuthor = new Leaf<Book>(authorComp);
  ABST<Book> lfPrice = new Leaf<Book>(priceComp);

  ABST<Book> treeTitle = new Node<Book>(titleComp, b2,
      new Node<Book>(titleComp, b1, lfTitle, lfTitle),
      new Node<Book>(titleComp, b2, lfTitle, lfTitle));

  ABST<Book> treeTitleAfterInsertB4 = new Node<Book>(titleComp, b2,
      new Node<Book>(titleComp, b1, lfTitle, lfTitle), new Node<Book>(titleComp, b2, lfTitle,
          new Node<Book>(titleComp, b4, new Leaf<Book>(titleComp), new Leaf<Book>(titleComp))));

  ABST<Book> treeTitleAfterInsertB5 = new Node<Book>(titleComp, b2,
      new Node<Book>(titleComp, b1, new Node<Book>(titleComp, b5, lfTitle, lfTitle), lfTitle),
      new Node<Book>(titleComp, b2, lfTitle, lfTitle));

  ABST<Book> treeTitleAfterGetAllButLeast = new Node<Book>(titleComp, b2, 
      new Leaf<Book>(titleComp),
      new Node<Book>(titleComp, b2, lfTitle, lfTitle));

  ABST<Book> treeAuthor = new Node<Book>(authorComp, b3,
      new Node<Book>(authorComp, b1, lfTitle, lfTitle),
      new Node<Book>(authorComp, b2, lfTitle, lfTitle));

  ABST<Book> treePrice = new Node<Book>(priceComp, b3,
      new Node<Book>(priceComp, b2, lfTitle, lfTitle),
      new Node<Book>(priceComp, b1, lfTitle, lfTitle));
  
  
  boolean testsss(Tester t) {
    return t.checkExpect(treePrice.getLeast(), b2);
  }
  
  boolean testWWWW(Tester t) {
    return t.checkExpect(treeTitle.getAllButLeast(), treeTitleAfterGetAllButLeast);
  }
}