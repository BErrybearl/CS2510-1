import tester.*;

// to represent the Comparator class 
interface IStringsCompare {

  // to determine whether String1 comes before String2
  boolean comesBefore(String s1, String s2);

}

class StringZetabetComp implements IStringsCompare {

  public boolean comesBefore(String s1, String s2) {
    return s1.compareTo(s2) >= 0;
  }

}

class StringLengthComp implements IStringsCompare {

  public boolean comesBefore(String s1, String s2) {
    return s1.length() <= s2.length();
  }
}

interface ILoString {

  boolean isSorted(IStringsCompare c);

  boolean isSortedHelp(String s, IStringsCompare c);

  ILoString merge(ILoString given, IStringsCompare c);

  ILoString mergeHelper(String given, IStringsCompare c);

  ILoString insert(String given, IStringsCompare c);

  // sort this ILoString
  ILoString sort(IStringsCompare c);

  // determine if this ILoString is the same as the given ILoString
  boolean sameList(ILoString given);

  // determine if this ILoString is the same MtLoString as the given MtLoString
  boolean sameMt(MtLoString given);

  // determine if this ILoString is the same ConsLoString as the given
  // ConsLoString
  boolean sameCons(ConsLoString given);

}

class MtLoString implements ILoString {

  /*
   * METHODS this.isSorted(IStringsCompare c) -- boolean
   * this.isSortedHelp(String, IStringsCompare c) -- boolean
   * this.merge(ILoString given, IStringsCompare c) -- ILoString
   * this.mergeHelper(String given, IStringsCompare c) -- ILoString
   * this.insert(String given, IStringsCompare c) -- ILoString
   * this.sort(StringsCompare c) -- ILoString this.sameList(ILoString given) --
   * boolean this.sameMt(MtLoString given) -- boolean this.sameCons(ConsLoString
   * given) -- boolean
   */

  // determine if this ILoString is sorted
  public boolean isSorted(IStringsCompare c) {
    return true;
  }

  // help determine if this ILoString is sorted
  public boolean isSortedHelp(String s, IStringsCompare c) {
    return true;
  }

  // merge this ILoString with the given ILoString
  public ILoString merge(ILoString given, IStringsCompare c) {
    return given;
  }

  // help merge this ILoString with the given ILoString
  public ILoString mergeHelper(String given, IStringsCompare c) {
    return this;
  }

  // insert the given String into this ILoString
  public ILoString insert(String given, IStringsCompare c) {
    return new ConsLoString(given, this);
  }

  // sort this ILoString
  public ILoString sort(IStringsCompare c) {
    return this;
  }

  // determine if this ILoString is the same as the given ILoString
  public boolean sameList(ILoString given) {
    return given.sameMt(this);
  }

  // determine if this ILoString is the same MtLoString as the given MtLoString
  public boolean sameMt(MtLoString given) {
    return true;
  }

  // determine if this ILoString is the same ConsLoString as the given
  // ConsLoString
  public boolean sameCons(ConsLoString given) {
    return false;
  }

}

class ConsLoString implements ILoString {

  String first;
  ILoString rest;

  ConsLoString(String first, ILoString rest) {
    this.first = first;
    this.rest = rest;
  }

  public boolean isSorted(IStringsCompare c) {
    return this.rest.isSortedHelp(first, c);
  }

  public boolean isSortedHelp(String s, IStringsCompare c) {
    return c.comesBefore(s, first) && this.rest.isSorted(c);
  }

  public ILoString merge(ILoString given, IStringsCompare c) {
    if (given instanceof MtLoString) {
      return this;
    }
    else {
      return this.mergeCons((ConsLoString) given, (IStringsCompare) c);
    }
  }

  // merge two sorted conslists into one sorted conslist by the given way
  ILoString mergeCons(ConsLoString los, IStringsCompare c) {
    return this.mergeHelper(los.first, c).merge(los.rest, c);
  }

  // insert a string into a sorted list by the give way
  public ILoString mergeHelper(String given, IStringsCompare c) {
    if (c.comesBefore(given, this.first)) {
      return new ConsLoString(given, this);
    }
    else {
      return new ConsLoString(this.first, this.rest.mergeHelper(given, c));
    }
  }

  public ILoString insert(String given, IStringsCompare c) {
    if (c.comesBefore(given, first)) {
      return new ConsLoString(given, this);
    }
    else {
      return new ConsLoString(this.first, this.rest.insert(given, c));
    }
  }

  public ILoString sort(IStringsCompare c) {
    return this.rest.sort(c).insert(this.first, c);
  }

  public boolean sameList(ILoString given) {
    return given.sameCons(this);
  }

  public boolean sameMt(MtLoString given) {
    return false;
  }

  public boolean sameCons(ConsLoString given) {
    return this.first.equals(given.first) && this.rest.sameList(given);
  }
}

class ExamplesStringsTests {

  ILoString los1 = new MtLoString();
  ILoString los2 = new ConsLoString("universally", los1);
  ILoString los3 = new ConsLoString("distortion", los2);
  ILoString los4 = new ConsLoString("fuzz", los3);
  ILoString los5 = new ConsLoString("dream", los1);
  ILoString los6 = new ConsLoString("excessive", los5);
  ILoString los7 = new ConsLoString("web", los6);

  IStringsCompare lexcomp = new StringZetabetComp();
  IStringsCompare lencomp = new StringLengthComp();

  boolean testIsSorted(Tester t) {
    return t.checkExpect(los1.isSorted(lencomp), true)
        && t.checkExpect(los2.isSorted(lencomp), true)
        && t.checkExpect(los3.isSorted(lexcomp), false)
        && t.checkExpect(los4.isSorted(lexcomp), true);

  }

  boolean testIsSortedHelp(Tester t) {
    return t.checkExpect(los1.isSortedHelp("", lencomp), true)
        && t.checkExpect(los2.isSortedHelp("", lencomp), true)
        && t.checkExpect(los3.isSortedHelp("", lexcomp), true)
        && t.checkExpect(los4.isSortedHelp("", lexcomp), true);
  }

  boolean testMerge(Tester t) {
    return t.checkExpect(los1.sameList(los1), true) 
        && t.checkExpect(los2.sameList(los2), false)
        && t.checkExpect(los3.sameList(los3), false) 
        && t.checkExpect(los4.sameList(los4), false);
  }

  boolean testMergeHelper(Tester t) {
    return t.checkExpect(los1.mergeHelper("", lencomp), los1) 
        && t.checkExpect(los2.mergeHelper("", lencomp), los2) 
        && t.checkExpect(los3.mergeHelper("", lencomp), true) 
        && t.checkExpect(los4.mergeHelper("", lencomp), true) ;
  }
  
  boolean testInsert(Tester t) {
    return t.checkExpect(los1.insert("", lexcomp), true) 
        && t.checkExpect(los2.insert("", lexcomp), true) 
        && t.checkExpect(los3.insert("", lexcomp), true) 
        && t.checkExpect(los4.insert("", lexcomp), true) ;
  }
  
  boolean testSort(Tester t) {
    return t.checkExpect(los1.sort(lexcomp), true) 
        && t.checkExpect(los2.sort(lexcomp), true) 
        && t.checkExpect(los3.sort(lexcomp), true)  
        && t.checkExpect(los4.sort(lexcomp), true) ;
  }

  boolean testSameMt(Tester t) {
    return t.checkExpect(los1.sameMt((MtLoString) los1), true);

  }

  boolean testSameCons(Tester t) {
    return t.checkExpect(los1.sameCons((ConsLoString) los4), false)
        && t.checkExpect(los2.sameCons((ConsLoString) los4), false)
        && t.checkExpect(los2.sameCons((ConsLoString) los2), true)
        && t.checkExpect(los4.sameCons((ConsLoString) los4), true);

  }

}