import java.awt.Color;
import java.util.Random;

import tester.*;
import javalib.funworld.*;
import javalib.worldimages.*;

abstract class AFish {

  Posn center;
  int radius;
  Color col;

  public AFish(Posn center, int radius, Color col) {
    this.center = center;
    this.radius = radius;
    this.col = col;
  }

  public WorldImage fishImage() {
    return new CircleImage(this.radius, "solid", this.col);
  }

  public abstract boolean canEat(AFish that);

  public int distance(AFish that) {
    int xDifference = this.center.x - that.center.x;
    int yDifference = this.center.y - that.center.y;

    return (int) Math.sqrt(xDifference * xDifference + yDifference * yDifference);
  }
}

class Fish extends AFish{

  Fish(Posn center, int radius, Color col) {
    super(center, radius, col);
  }

  public Fish moveFish(String ke) {
    if (ke.equals("right")) {
      return new Fish(new Posn(this.center.x + 5, this.center.y), this.radius, this.col);
    }
    else if (ke.equals("left")) {
      return new Fish(new Posn(this.center.x - 5, this.center.y), this.radius, this.col);
    }
    else if (ke.equals("up")) {
      return new Fish(new Posn(this.center.x, this.center.y - 5), this.radius, this.col);
    }
    else if (ke.equals("down")) {
      return new Fish(new Posn(this.center.x, this.center.y + 5), this.radius, this.col);
    }
    else if (ke.equals("Y")) {
      return new Fish(this.center, this.radius, Color.YELLOW);
    }
    else if (ke.equals("G")) {
      return new Fish(this.center, this.radius, Color.GREEN);
    }
    else if (ke.equals("R")) {
      return new Fish(this.center, this.radius, Color.RED);
    }
    else
      return this;
  }

  public boolean canEat(AFish given) {
    if ((this.radius >= given.radius) && (this.distance(given) <= this.radius + given.radius)) {
      return true;
    }
    else {
      return false;
    }
  } 

  public Fish updateFish(ILoFish other) {
    return new Fish(this.center, this.radius + other.getEatenRadius(this), this.col);
  }
}

class OtherFish extends AFish{

  boolean goingLeft;

  OtherFish(Posn center, int radius, Color col, boolean goingLeft) {
    super(center, radius, col);
    this.goingLeft = goingLeft;
  }

  public OtherFish moveOtherfish(int n) {

    Random r = new Random();

    if (this.goingLeft && this.center.x <= 0) {
      return new OtherFish(new Posn(this.center.x + n, r.nextInt(FishyWorld.HEIGHT)), this.radius, this.col, !this.goingLeft);
    }
    else if (this.goingLeft && this.center.x >= 0) {
      return new OtherFish(new Posn(this.center.x - n, this.center.y), this.radius, this.col, this.goingLeft);
    }
    else if (!this.goingLeft && this.center.x >= FishyWorld.WIDTH) {
      return new OtherFish(new Posn(this.center.x - n, r.nextInt(FishyWorld.HEIGHT)), this.radius, this.col, !this.goingLeft);
    }
    else {
      return new OtherFish(new Posn(this.center.x + n, this.center.y), this.radius, this.col, this.goingLeft);
    }
  }

  public boolean canEat(AFish given) {
    if ((this.radius > given.radius) && (this.distance(given) <= this.radius + given.radius)) {
      return true;
    }
    else {
      return false;
    }
  }

  int getRadius() {
    return this.radius;
  }
}

interface ILoFish {
  
  ILoFish moveAllOtherfish(int n);

  public int getEatenRadius(AFish that);

  boolean compareSize(AFish given);

  WorldScene renderFish(WorldScene accu);

  boolean canEat(AFish given);

  ILoFish updateList(AFish player);

  public boolean anyCanEat(AFish given);
}

class MtLoFish implements ILoFish {

  public ILoFish moveAllOtherfish(int n) {
    return this;
  }
  
  public int getEatenRadius(AFish that) {
    return 0;
  }

  public boolean compareSize(AFish given) {
    return true;
  }

  public WorldScene renderFish(WorldScene accu) {
    return accu;
  }

  public boolean canEat(AFish given) {
    return false;
  }

  public ILoFish updateList(AFish player) {
    return this;
  }

  public boolean anyCanEat(AFish given) {
    return false;
  }
}

class ConsLoFish implements ILoFish {
  OtherFish first;
  ILoFish rest;

  ConsLoFish(OtherFish first, ILoFish rest) {
    this.first = first;
    this.rest = rest;
  }

  public ILoFish moveAllOtherfish(int n) {
    return new ConsLoFish(this.first.moveOtherfish(n), this.rest.moveAllOtherfish(n));
  }


  public boolean compareSize(AFish given) {
    return (this.first.getRadius() < given.radius) && this.rest.compareSize(given);
  }

  public WorldScene renderFish(WorldScene accu) {
    return this.rest.renderFish(
        accu.placeImageXY(this.first.fishImage(), this.first.center.x, this.first.center.y));
  }

  public boolean canEat(AFish given) {
    if (given.canEat(this.first)) {
      return true;
    }
    return this.rest.canEat(given);
  }

  public ILoFish updateList(AFish player) {
    if (player.canEat(this.first)) {
      return this.rest.updateList(player);
    }
    else {
      return new ConsLoFish(this.first, this.rest.updateList(player));
    }
  }

  public int getEatenRadius(AFish that) {
    if (that.canEat(this.first)) {
      return this.first.getRadius() + this.rest.getEatenRadius(that);
    }
    else return this.rest.getEatenRadius(that);
  }

  public boolean anyCanEat(AFish given) {
    return first.canEat(given) || this.rest.anyCanEat(given);
  }  
}

class FishyWorld extends World {

  static int WIDTH = 400;
  static int HEIGHT = 400;

  Fish player;
  ILoFish otherfish;

  public FishyWorld(Fish player, ILoFish otherfish) {
    this.player = player;
    this.otherfish = otherfish;
  }

  public World onKeyEvent(String ke) {
    if (player.center.x < 0) {
      return new FishyWorld(new Fish(new Posn(FishyWorld.WIDTH, player.center.y), player.radius, player.col),
          otherfish);
    }
    else if (player.center.x > FishyWorld.WIDTH) {
      return new FishyWorld(new Fish(new Posn(0, player.center.y), player.radius, player.col),
          otherfish);
    }
    else if (player.center.y > FishyWorld.HEIGHT) {
      return new FishyWorld(new Fish(new Posn(player.center.x, FishyWorld.HEIGHT), player.radius, player.col),
          otherfish);
    }
    else if (player.center.y < 0) {
      return new FishyWorld(new Fish(new Posn(player.center.x, 0), player.radius, player.col),
          otherfish);
    }
    else return new FishyWorld(this.player.moveFish(ke), otherfish);
  }

  public World onTick() { 
    return new FishyWorld(this.player.updateFish(otherfish), this.otherfish.updateList(player).moveAllOtherfish(5));
  }

  public WorldEnd worldEnds() {
    if (otherfish.compareSize(player)) {
      return new WorldEnd(true, this.lastScene("You Win"));
    }
    else if (otherfish.anyCanEat(player)) {
      return new WorldEnd(true, this.lastScene("You lost"));
    }
    return new WorldEnd(false, this.makeScene());
  }

  public WorldScene lastScene(String s) {
    return this.makeScene().placeImageXY(new TextImage(s, Color.red), FishyWorld.WIDTH / 2, FishyWorld.HEIGHT / 2);
  }

  public WorldScene makeScene() {
    return renderFish(this.getEmptyScene());
  }

  public WorldScene renderFish(WorldScene accu) {
    return this.otherfish.renderFish(
        accu.placeImageXY(this.player.fishImage(), this.player.center.x, this.player.center.y));
  }
}
class FishyExamples {

  Fish p1 = new Fish(new Posn(FishyWorld.WIDTH / 2, FishyWorld.HEIGHT / 2), 6, Color.black);

  OtherFish f1 = new OtherFish(new Posn(0, FishyWorld.HEIGHT / 2), 2, Color.red, false);
  OtherFish f2 = new OtherFish(new Posn(FishyWorld.WIDTH, 50), 5, Color.red, true);
  OtherFish f3 = new OtherFish(new Posn(FishyWorld.WIDTH, 150), 13, Color.red, true);

  ILoFish o1 = new ConsLoFish(this.f1,
      new ConsLoFish(this.f2, new ConsLoFish(this.f3, new MtLoFish())));

  FishyWorld w1 = new FishyWorld(p1, o1);

  boolean runAnimation1 = this.w1.bigBang(FishyWorld.HEIGHT, FishyWorld.WIDTH, 0.05);
}
